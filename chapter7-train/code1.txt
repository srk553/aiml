
/* ---------- data ---------- */
const data = [
  { r: 255, g: 0, b: 0, color: "red-ish" },
  { r: 254, g: 0, b: 0, color: "red-ish" },
  { r: 253, g: 0, b: 0, color: "red-ish" },
  { r: 0, g: 255, b: 0, color: "green-ish" },
  { r: 0, g: 254, b: 0, color: "green-ish" },
  { r: 0, g: 253, b: 0, color: "green-ish" },
  { r: 0, g: 0, b: 255, color: "blue-ish" },
  { r: 0, g: 0, b: 254, color: "blue-ish" },
  { r: 0, g: 0, b: 253, color: "blue-ish" },
];

let classifier;
let r = 255, g = 0, b = 0;
let rSlider, gSlider, bSlider;
let label = "training";

/* ---------- p5 setup ---------- */
function setup() {
  createCanvas(640, 240);

  // 1) Set backend BEFORE creating neuralNetwork (helps avoid webgpu/backend errors)
  //    Try 'cpu' first; if you want GPU try 'webgl'.
  if (ml5 && typeof ml5.setBackend === 'function') {
    try {
      ml5.setBackend('cpu');
      console.log('ml5.setBackend("cpu") called');
    } catch (e) {
      console.warn('ml5.setBackend failed:', e);
    }
  }

  // sliders
  rSlider = createSlider(0, 255, 0).position(10, 20);
  gSlider = createSlider(0, 255, 125).position(10, 40);
  bSlider = createSlider(0, 255, 0).position(10, 60);

  // 2) Define network options - give named inputs/outputs to avoid ambiguity
  const options = {
    inputs: ['r', 'g', 'b'],
    outputs: ['color'],
    task: 'classification',
    debug: true,
  };

  // 3) Create network
  classifier = ml5.neuralNetwork(options);

  // 4) Add data (use objects for inputs, and object with 'label' for output)
  for (let item of data) {

    classifier.addData(
      { r: item.r, g: item.g, b: item.b },
      { color: item.color } // Keep 'color' as the output name (matches options.outputs)
    );
  }

  // 5) Normalize
  classifier.normalizeData();

  // 6) Train - keep batchSize <= number of samples
  const trainingOptions = {
    epochs: 32,
    batchSize: 3
  };

  // Train with a whileTraining callback to see progress, and finishedTraining when done
  classifier.train(trainingOptions, whileTraining, finishedTraining);
}

function whileTraining(epoch, logs) {
  // logs may be undefined on some versions — guard it
  console.log('epoch', epoch, 'loss:', logs && (logs.loss ?? logs));
}

function finishedTraining() {
  console.log('Training complete ✅');
  setTimeout(classify, 100); // give TF a moment to finalize model

  classify(); // start classify loop
}

/* ---------- classify / draw ---------- */
function classify() {
  try {
    classifier.classify({ r: r, g: g, b: b }, handleResults);
  } catch (err) {
    console.warn('classify threw an exception:', err);
    setTimeout(classify, 100); // retry after short delay
  }
}

function draw() {
  r = rSlider.value();
  g = gSlider.value();
  b = bSlider.value();
  background(r, g, b);

  noStroke();
  textAlign(CENTER, CENTER);
  textSize(48);

  // draw label with contrast so it's readable
  fill(255 - r, 255 - g, 255 - b);
  text(label, width / 2, height / 2);
}

/* ---------- results callback (error first) ---------- */
function handleResults(errOrResults, maybeResults) {
  let results;
  
  if (Array.isArray(errOrResults)) {
    // old behavior: first arg is results
    results = errOrResults;
  } else {
    // new behavior: first arg is error, second is results
    if (errOrResults) {
      console.error("classify error:", errOrResults);
      label = "error";
      return;
    }
    results = maybeResults;
  }

  if (!results || !results[0]) {
    label = "no result";
    return;
  }

  console.log('results:', results);
  label = results[0].label;

  // classify(); // loop classify
}
